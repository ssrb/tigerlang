

%{
(* M68000 Code generator *)
%}

%term LABEL 
	| JUMP
	| CJUMP
	| CONST
    | ADD
	| ADDA
	| ADDI
	| ADDQ
	| ADDX
	| CLR
	| CMP
	| CMPA
	| CMPI
	| CMPM
	| CMP2
	| DIVS
	| DIVU
	| DIVSL
	| DIVUL
	| EXT
	| EXTB
	| MULS
	| MULU
    | NEG
	| NEGX
	| SUB
	| SUBA
	| SUBI
	| SUBQ
	| SUBX

%termprefix T_
%ruleprefix R_

%start stm

%%

stm: LABEL = stm_label (0);
stm: JUMP = stm_jump (0);

stm: CJUMP(dreg, dreg) = stm_cjump_d_d;
stm: CJUMP(areg, areg) = stm_cjump_a_a;

stm: dreg = stm_reg (0);
stm: areg = stm_areg (0);

dreg: CONST	= CONST_d (1);
areg: CONST	= CONST_a (1);

dreg: ADD(dreg, dreg)	= ADD_d_d	(1);
dreg: ADD(CONST, dreg)	= ADD_k_d	(1);
dreg: ADD(dreg, CONST)	= ADD_d_k	(1);

areg: ADDA(areg,dreg)	= ADDA_a_d	(1);
dreg: ADDI(dreg,dreg)	= ADDI_d_d	(1);
dreg: ADDQ(dreg,dreg)	= ADDQ_d_d	(1);
dreg: ADDX(dreg,dreg)	= ADDX_d_d	(1);

dreg: CLR(dreg,dreg)	= CLR_d_d	(1);

dreg: CMP(dreg,dreg)	= CMP_d_d	(1);
dreg: CMPA(dreg,dreg)	= CMPA_d_d	(1);
dreg: CMPI(dreg,dreg)	= CMPI_d_d	(1);
dreg: CMPM(dreg,dreg)	= CMPN_d_d	(1);
dreg: CMP2(dreg,dreg)	= CMP2_d_d	(1);

dreg: DIVU(dreg, dreg)	= DIVU_d_d	(1);
dreg: DIVU(CONST, dreg)	= DIVU_k_d	(1);
dreg: DIVU(dreg, CONST)	= DIVU_d_k	(1);

dreg: DIVS(dreg,dreg)	= DIVS_d_d	(1);
dreg: DIVSL(dreg,dreg) 	= DIVSL_d_d	(1);
dreg: DIVUL(dreg,dreg) 	= DIVUL_d_d	(1);

dreg: EXT(dreg,dreg)	= EXT_d_d	(1);
dreg: EXTB(dreg,dreg)	= EXTB_d_d	(1);

dreg: MULU(dreg, dreg)	= MULU_d_d	(1);
dreg: MULU(CONST, dreg)	= MULU_k_d	(1);
dreg: MULU(dreg, CONST)	= MULU_d_k	(1);

dreg: MULS(dreg,dreg)	= MULS_d_d	(1);
dreg: NEGX(dreg,dreg)	= NEGX_d_d	(1);

dreg: SUB(dreg, dreg)	= ADD_d_d	(1);
dreg: SUB(CONST, dreg)	= ADD_k_d	(1);
dreg: SUB(dreg, CONST)	= ADD_d_k	(1);

dreg: SUBA(dreg,dreg)	= SUBA_d_d	(1);
dreg: SUBI(dreg,dreg)	= SUBI_d_d	(1);
dreg: SUBQ(dreg,dreg)	= SUBQ_d_d	(1);
dreg: SUBX(dreg,dreg)	= SUBX_d_d	(1);

dreg: NEG(dreg)	= NEG_r		(2);


%%

module In = struct

  open BurmOps

  type tree = M68kFrame.Tree.stm

  let opchildren stm = 
  	let open M68kFrame.Tree in
	match stm with
  	| SEQ _ -> assert(false)
	| LABEL _ -> (T_LABEL, [])
	| JUMP _ -> (T_JUMP, [])
	| CJUMP (relop, exp1, exp2, label1, label2) ->
		 (T_CJUMP, [(EXP exp1); (EXP exp2)])
	| MOVE (exp1, exp2) -> (T_CONST, [])
	| EXP exp -> 
	begin
		match exp.t with
		| BINOP (binop, exp1, exp2) ->
		begin
			match binop with
			| PLUS -> (T_ADD, [(EXP exp1); (EXP exp2)])
			| MINUS -> (T_SUB,[(EXP exp1); (EXP exp2)])
			| MUL -> (T_MULU, [(EXP exp1); (EXP exp2)])
			| DIV -> (T_DIVU, [(EXP exp1); (EXP exp2)])
			| AND -> (T_CONST, [])
			| OR -> (T_CONST, [])
			| LSHIFT -> (T_CONST, [])
			| RSHIFT -> (T_CONST, [])
			| ARSHIFT -> (T_CONST, [])
			| XOR -> (T_CONST, [])
		end
		| MEM exp -> (T_CONST, [])
		| TEMP temp -> (T_CONST, [])
		| ESEQ (stm, exp) -> (T_CONST, [])
		| NAME label -> (T_CONST, [])
		| CONST int -> (T_CONST, [])
		| CALL (exp, exps) -> (T_CONST, [])
	end
	| M68kFrame.Tree.NOP -> (T_CONST, [])
end

module Generator : Codegen.T with module Frame = M68kFrame = struct 

	module Frame = M68kFrame
	module Tree = Frame.Tree
	module Temp = Frame.Temp
	module Assem = Frame.Assem
	module Var = Assem.Variable
	module Burm = BurmGen (In)

	open Core
	open Tree
 	open In

	let codegen frame stm =
		let module A = Assem in
		let ilist = ref [] in
		let emit x = ilist := x::!ilist in
		let data gen = 
			let v = Var.make (Temp.newtemp(), "d") in 
			gen v; 
			v
		in
		let address gen = 
			let v = Var.make (Temp.newtemp(), "a") in 
			gen v; 
			v
		in
		let rec walk t =
			match t with
			| (Burm.R_ADD_d_d (r0,r1), _) ->
			 	let s0 = walk r0 in
				let s1 = walk r1 in
				data(fun r -> 
					emit(A.MOVE {assem = "move.l `s0,`d0"; dst = r; src = s0});
					emit(A.OPER {assem = "add.l `s0,`d0"; dst = [r]; src = [s1; r]; jump = None}))   
			| _ -> (Out_channel.print_endline "Error, bad match in walk"; raise Burm.NoMatch)
		in
		let emit_relop relop t f =
			match relop with 
			| EQ -> 
				emit(A.OPER {assem = "beq " ^ (Symbol.name t); dst = []; src = []; jump = Some [t; f]})
			| NE ->
				emit(A.OPER {assem = "bne " ^ (Symbol.name t); dst = []; src = []; jump = Some [t; f]})
			| LT | ULT ->
				emit(A.OPER {assem = "blt " ^ (Symbol.name t); dst = []; src = []; jump = Some [t; f]})
			| GT | UGT ->
				emit(A.OPER {assem = "bgt " ^ (Symbol.name t); dst = []; src = []; jump = Some [t; f]})
			| LE | ULE ->
				emit(A.OPER {assem = "ble " ^ (Symbol.name t); dst = []; src = []; jump = Some [t; f]})
			| GE | UGE ->
				emit(A.OPER {assem = "bge " ^ (Symbol.name t); dst = []; src = []; jump = Some [t; f]})
		in
		let walk_stm t =
			let module A = Assem in
			match t with
			| (Burm.R_stm_label, LABEL label) -> 
            	emit(A.LABEL {assem = (Symbol.name label) ^ ":"; lab = label});
			| (Burm.R_stm_jump, JUMP ({ t = NAME l }, lbls)) ->
				emit(A.OPER {assem = "jmp " ^ (Symbol.name l); dst = []; src = []; jump = Some lbls})
			| (Burm.R_stm_cjump_d_d (e0, e1), CJUMP (relop, _, _, t, f)) ->
				emit(A.OPER {assem = "cmp.l `s1,`s0"; dst = []; src = [walk e0; walk e1]; jump = None});
				emit_relop relop t f
			| (Burm.R_stm_cjump_a_a (e0, e1), CJUMP (relop, _, _, t, f)) ->
				emit(A.OPER {assem = "cmpa.l `s1,`s0"; dst = []; src = [walk e0; walk e1]; jump = None});
				emit_relop relop t f
			| _ -> (Out_channel.print_endline "Error, bad match in walk_stm"; raise Burm.NoMatch)
		in
		
		walk_stm (Burm.reduce stm);
		List.rev(!ilist)

end
