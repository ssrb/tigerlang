

%{
(* M68000 Code generator *)
%}



%term INT
    | VAR
    | ADD
	| ADDA
	| ADDI
	| ADDQ
	| ADDX
	| CLR
	| CMP
	| CMPA
	| CMPI
	| CMPM
	| CMP2
	| DIVS
	| DIVU
	| DIVSL
	| DIVUL
	| EXT
	| EXTB
	| MULS
	| MULU
    | NEG
	| NEGX
	| SUB
	| SUBA
	| SUBI
	| SUBQ
	| SUBX

%termprefix T_
%ruleprefix R_

%start reg

%%


reg:	INT		= reg_INT		(1);
sreg:	INT		= sreg_INT		(1);
ureg:	INT		= ureg_INT		(1);

reg:	VAR		= reg_VAR		(1); (* fetch *)

reg:	sreg		= reg_sreg		(1); (* inc *)
sreg:	reg		= sreg_reg		(1); (* dec *)
sreg:	ureg		= sreg_ureg		(1); (* shl *)
ureg:	sreg		= ureg_sreg_or_reg	(1); (* shr *)
ureg:	reg		= ureg_sreg_or_reg	(1); (* shr *)

reg:	ADD(reg,sreg)	= r_ADD_r_r		(1); (* add *)
reg:	ADD(sreg,reg)	= r_ADD_r_r		(1); (* add *)
reg:	ADD(INT,reg)	= r_ADD_2i_r		(1); (* add 2*imm *)
reg:	ADD(reg,INT)	= r_ADD_r_2i		(1); (* add 2*imm *)
reg:	ADD(INT,sreg)	= r_ADD_2ip_r		(1); (* add 2*imm+1 *)
reg:	ADD(sreg,INT)	= r_ADD_r_2ip		(1); (* add 2*imm+1 *)
sreg:	ADD(sreg,sreg)	= r_ADD_r_r		(1); (* add *)
sreg:	ADD(INT,sreg)	= r_ADD_2i_r		(1); (* add 2*imm *)
sreg:	ADD(sreg,INT)	= r_ADD_r_2i		(1); (* add 2*imm *)
sreg:	ADD(INT,reg)	= r_ADD_2im_r		(1); (* add 2*imm-1 *)
sreg:	ADD(reg,INT)	= r_ADD_r_2im		(1); (* add 2*imm-1 *)

reg:	SUB(reg,sreg)	= r_SUB_r_r		(1); (* sub *)
reg:	SUB(INT,reg)	= r_SUB_2ipp_r		(2); (* sub 2*imm+2,x *)
reg:	SUB(reg,INT)	= r_SUB_r_2i		(1); (* sub x,2*imm *)
reg:	SUB(sreg,INT)	= r_SUB_r_2im		(1); (* sub x,2*imm-1 *)
sreg:	SUB(sreg,sreg)	= r_SUB_r_r		(1); (* sub *)
sreg:	SUB(reg,reg)	= r_SUB_r_r		(1); (* sub *)
sreg:	SUB(sreg,INT)	= r_SUB_r_2i		(1); (* sub x,2*imm *)
sreg:	SUB(reg,INT)	= r_SUB_r_2ip		(1); (* sub x,2*imm+1 *)

sreg:	MULU(sreg,ureg)	= r_MUL_r_r		(1); (* mul *)
sreg:	MULU(ureg,sreg)	= r_MUL_r_r		(1); (* mul *)
sreg:	MULU(INT,sreg)	= r_MUL_i_r		(1); (* mul *)
sreg:	MULU(sreg,INT)	= r_MUL_r_i		(1); (* mul *)
sreg:	MULU(INT,ureg)	= r_MUL_2i_r		(1); (* mul 2*imm,x *)
sreg:	MULU(ureg,INT)	= r_MUL_r_2i		(1); (* mul x,2*imm *)

reg: ADDA(reg,sreg)	= r_ADDA_r_r		(1); (* sub *)
reg: ADDI(reg,sreg)	= r_ADDI_r_r		(1); (* sub *)
reg: ADDQ(reg,sreg)	= r_ADDQ_r_r		(1); (* sub *)
reg: ADDX(reg,sreg)	= r_ADDX_r_r		(1); (* sub *)
reg: CLR(reg,sreg)	= r_CLR_r_r		(1); (* sub *)
reg: CMP(reg,sreg)	= r_CMP_r_r		(1); (* sub *)
reg: CMPA(reg,sreg)	= r_CMPA_r_r		(1); (* sub *)
reg: CMPI(reg,sreg)	= r_CMPI_r_r		(1); (* sub *)
reg: CMPM(reg,sreg)	= r_CMPN_r_r		(1); (* sub *)
reg: CMP2(reg,sreg)	= r_CMP2_r_r		(1); (* sub *)
reg: DIVS(reg,sreg)	= r_DIVS_r_r		(1); (* sub *)
reg: DIVSL(reg,sreg) = r_DIVSL_r_r	(1); (* sub *)
reg: DIVUL(reg,sreg) = r_DIVUL_r_r	(1); (* sub *)
reg: EXT(reg,sreg)	= r_EXT_r_r		(1); (* sub *)
reg: EXTB(reg,sreg)	= r_EXTB_r_r		(1); (* sub *)
reg: MULS(reg,sreg)	= r_MULS_r_r		(1); (* sub *)
reg: NEGX(reg,sreg)	= r_NEGX_r_r		(1); (* sub *)
reg: SUBA(reg,sreg)	= r_SUBA_r_r		(1); (* sub *)
reg: SUBI(reg,sreg)	= r_SUBI_r_r		(1); (* sub *)
reg: SUBQ(reg,sreg)	= r_SUBQ_r_r		(1); (* sub *)
reg: SUBX(reg,sreg)	= r_SUBX_r_r		(1); (* sub *)

ureg:	DIVU(sreg,sreg)	= r_DIV_r_r		(1); (* div *)
ureg:	DIVU(ureg,ureg)	= r_DIV_r_r		(1); (* div *)
ureg:	DIVU(ureg,INT)	= r_DIV_r_i		(1); (* div *)

reg:	NEG(reg)	= r_NEG_r_p_2		(2); (* 2-r *)
ureg:	NEG(ureg)	= r_NEG_r		(1); (* 0-r *)
sreg:	NEG(sreg)	= r_NEG_r		(1); (* 0-r *)

%%

module In = struct

  open BurmOps

  type tree = M68kFrame.Tree.stm

  let opchildren stm = 
  	let open M68kFrame.Tree in
	match stm with
  	| SEQ _ -> assert(false)
	| LABEL label -> (T_INT, [])
	| JUMP (exp, labels) -> (T_INT, [])
	| CJUMP (relop, exp1, exp2, label1, label2) -> (T_INT, [])
	| MOVE (exp1, exp2) -> (T_INT, [])
	| EXP exp -> 
	begin
		match exp.t with
		| BINOP (binop, exp1, exp2) ->
		begin
			match binop with
			| PLUS -> (T_INT, [])
			| MINUS -> (T_INT, [])
			| MUL -> (T_INT, [])
			| DIV -> (T_INT, [])
			| AND -> (T_INT, [])
			| OR -> (T_INT, [])
			| LSHIFT -> (T_INT, [])
			| RSHIFT -> (T_INT, [])
			| ARSHIFT -> (T_INT, [])
			| XOR -> (T_INT, [])
		end
		| MEM exp -> (T_INT, [])
		| TEMP temp -> (T_INT, [])
		| ESEQ (stm, exp) -> (T_INT, [])
		| NAME label -> (T_INT, [])
		| CONST int -> (T_INT, [])
		| CALL (exp, exps) -> (T_INT, [])
	end
	| M68kFrame.Tree.NOP -> (T_INT, [])
end

module Generator : Codegen.T with module Frame = M68kFrame = struct 

	module Frame = M68kFrame
	module Tree = Frame.Tree
	module Temp = Frame.Temp
	module Assem = Frame.Assem
	module Var = Assem.Variable
	module Burm = BurmGen (In)

	open Core
	open Tree
 	open In

	let codegen frame stm =
		let ilist = ref [] in
		let emit x = ilist := x::!ilist in
		let data gen = 
			let v = Var.make (Temp.newtemp(), "d") in 
			gen v; 
			v
		in
		let address gen = 
			let v = Var.make (Temp.newtemp(), "a") in 
			gen v; 
			v
		in
		let rec walk t =
			let module A = Assem in
			match t with
			| (Burm.R_r_ADD_r_r (r0,r1), _) ->
			 	let s0 = walk r0 in
				let s1 = walk r1 in
				data(fun r -> 
					emit(A.MOVE {assem = "move.l `s0,`d0"; dst = r; src = s0});
					emit(A.OPER {assem = "add.l `s0,`d0"; dst = [r]; src = [s1; r]; jump = None}))   
			| _ -> (Out_channel.print_endline "Error, bad match in walk"; raise Burm.NoMatch)
		in
		walk (Burm.reduce stm);
		List.rev(!ilist)

end
