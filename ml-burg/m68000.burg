

%{
(* M68000 Code generator *)
%}



%term INT
    | VAR
    | ADD
    | SUB
    | MUL
    | DIV
    | NEG

%termprefix T_
%ruleprefix R_

%start reg

%%


reg:	INT		= reg_INT		(1);
sreg:	INT		= sreg_INT		(1);
ureg:	INT		= ureg_INT		(1);

reg:	VAR		= reg_VAR		(1); (* fetch *)

reg:	sreg		= reg_sreg		(1); (* inc *)
sreg:	reg		= sreg_reg		(1); (* dec *)
sreg:	ureg		= sreg_ureg		(1); (* shl *)
ureg:	sreg		= ureg_sreg_or_reg	(1); (* shr *)
ureg:	reg		= ureg_sreg_or_reg	(1); (* shr *)

reg:	ADD(reg,sreg)	= r_ADD_r_r		(1); (* add *)
reg:	ADD(sreg,reg)	= r_ADD_r_r		(1); (* add *)
reg:	ADD(INT,reg)	= r_ADD_2i_r		(1); (* add 2*imm *)
reg:	ADD(reg,INT)	= r_ADD_r_2i		(1); (* add 2*imm *)
reg:	ADD(INT,sreg)	= r_ADD_2ip_r		(1); (* add 2*imm+1 *)
reg:	ADD(sreg,INT)	= r_ADD_r_2ip		(1); (* add 2*imm+1 *)
sreg:	ADD(sreg,sreg)	= r_ADD_r_r		(1); (* add *)
sreg:	ADD(INT,sreg)	= r_ADD_2i_r		(1); (* add 2*imm *)
sreg:	ADD(sreg,INT)	= r_ADD_r_2i		(1); (* add 2*imm *)
sreg:	ADD(INT,reg)	= r_ADD_2im_r		(1); (* add 2*imm-1 *)
sreg:	ADD(reg,INT)	= r_ADD_r_2im		(1); (* add 2*imm-1 *)

reg:	SUB(reg,sreg)	= r_SUB_r_r		(1); (* sub *)
reg:	SUB(INT,reg)	= r_SUB_2ipp_r		(2); (* sub 2*imm+2,x *)
reg:	SUB(reg,INT)	= r_SUB_r_2i		(1); (* sub x,2*imm *)
reg:	SUB(sreg,INT)	= r_SUB_r_2im		(1); (* sub x,2*imm-1 *)
sreg:	SUB(sreg,sreg)	= r_SUB_r_r		(1); (* sub *)
sreg:	SUB(reg,reg)	= r_SUB_r_r		(1); (* sub *)
sreg:	SUB(sreg,INT)	= r_SUB_r_2i		(1); (* sub x,2*imm *)
sreg:	SUB(reg,INT)	= r_SUB_r_2ip		(1); (* sub x,2*imm+1 *)

sreg:	MUL(sreg,ureg)	= r_MUL_r_r		(1); (* mul *)
sreg:	MUL(ureg,sreg)	= r_MUL_r_r		(1); (* mul *)
sreg:	MUL(INT,sreg)	= r_MUL_i_r		(1); (* mul *)
sreg:	MUL(sreg,INT)	= r_MUL_r_i		(1); (* mul *)
sreg:	MUL(INT,ureg)	= r_MUL_2i_r		(1); (* mul 2*imm,x *)
sreg:	MUL(ureg,INT)	= r_MUL_r_2i		(1); (* mul x,2*imm *)

ureg:	DIV(sreg,sreg)	= r_DIV_r_r		(1); (* div *)
ureg:	DIV(ureg,ureg)	= r_DIV_r_r		(1); (* div *)
ureg:	DIV(ureg,INT)	= r_DIV_r_i		(1); (* div *)

reg:	NEG(reg)	= r_NEG_r_p_2		(2); (* 2-r *)
ureg:	NEG(ureg)	= r_NEG_r		(1); (* 0-r *)
sreg:	NEG(sreg)	= r_NEG_r		(1); (* 0-r *)

%%

module In = struct

  open BurmOps

  type tree = M68kFrame.Tree.stm

  let opchildren = function
  	| M68kFrame.Tree.SEQ _ -> assert(false)
	| M68kFrame.Tree.LABEL label -> (T_INT, [])
	| M68kFrame.Tree.JUMP (exp, labels) -> (T_INT, [])
	| M68kFrame.Tree.CJUMP (relop, exp1, exp2, label1, label2) -> (T_INT, [])
	| M68kFrame.Tree.MOVE (exp1, exp2) -> (T_INT, [])
	| M68kFrame.Tree.EXP exp -> (T_INT, [])
	| M68kFrame.Tree.NOP -> (T_INT, [])
end

module Generator : Codegen.T with module Frame = M68kFrame = struct 

	module Frame = M68kFrame
	module Tree = Frame.Tree
	module Temp = Frame.Temp
	module Assem = Frame.Assem
	module Var = Assem.Variable
	module Burm = BurmGen (In)

	open Core
	open Tree
 	open In

	let codegen frame stm =
		let ilist = ref [] in
		let emit x = ilist := x::!ilist in
		let data gen = 
			let v = Var.make (Temp.newtemp(), "d") in 
			gen v; 
			v
		in
		let address gen = 
			let v = Var.make (Temp.newtemp(), "a") in 
			gen v; 
			v
		in
		let rec walk t =
			let module A = Assem in
			match t with
			| (Burm.R_reg_INT, EXP {t = CONST n}) ->
				emit(A.OPER {assem = "adda.l #" ^ (Int.to_string (132)) ^ ",sp"; dst = []; src = []; jump = None})
			| _ -> (Out_channel.print_endline "Error, bad match in walk"; raise Burm.NoMatch)
		in
		walk (Burm.reduce stm);
		List.rev(!ilist)

end

