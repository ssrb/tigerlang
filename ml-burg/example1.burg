

%{
(* this is the header *)
%}



%term ASGNI
    | ADDI
    | CVCI
    | INDIRC
    | I0I
    | ADDRLP
    | CNSTI

%termprefix T_

%start stmt


%%

stmt:   ASGNI(disp,reg)		= stmt_ASGNI_disp_reg	(1);
stmt:   reg			= stmt_reg;
reg:    ADDI(reg,rc)		= reg_ADDI_reg_rc	(1);
reg:    CVCI(INDIRC(disp))	= reg_CVCI_INDIRC_disp	(1);
reg:    I0I			= reg_I0I;
reg:    disp			= reg_disp		(1);
disp:   ADDI(reg,con)		= disp_ADDI_reg_con;
disp:   ADDRLP			= disp_ADDRLP;
rc:     con			= rc_con;
rc:     reg			= rc_reg;
con:    CNSTI			= con_CNSTI;
con:    I0I			= con_I0I;



%%

structure In = struct

  open BurmOps

  datatype tree =
    ASGNI of tree * tree
  | ADDI of tree * tree
  | CVCI of tree
  | INDIRC of tree
  | I0I
  | ADDRLP of string
  | CNSTI of int

  fun opchildren t =
    case t of
      ASGNI (t1,t2) => (T_ASGNI, [t1,t2])
    | ADDI (t1,t2) =>  (T_ADDI, [t1,t2])
    | CVCI (t1) =>     (T_CVCI, [t1])
    | INDIRC (t1) =>   (T_INDIRC, [t1])
    | I0I =>           (T_I0I, [])
    | ADDRLP _ =>      (T_ADDRLP, [])
    | CNSTI _ =>       (T_CNSTI, [])

end




module Example = struct 

  module Burm = BurmGen (In)
  open In

  let say s = Core.Out_channel.print_string s

	let num = ref 1
	let inc iref = iref := !iref + 1
  let new s =  let t = !num in inc num; s ^ (Int.toString t)

  let walk = function
	| (Burm.stmt_ASGNI_disp_reg (disp,reg), _) ->
		let (disp',reg') = (walk disp, walk reg) in
		let val stmt = new "stmt" in
	  say (stmt^" <- ASGNI ("^disp'^" + "^reg'^")\n"); 
		stmt
  | (Burm.stmt_reg reg, _) ->
		let reg' = walk reg in
	  let stmt = new "stmt" in
	  say (stmt^" <- "^reg'^"\n"); 
		stmt
  | (Burm.reg_ADDI_reg_rc (reg,rc), _) ->
		let (reg',rc') = (walk reg, walk rc) in
	  let reg2 = new "reg" in
	  say (reg2^" <- ADDI ("^reg'^","^rc'^")\n"); 
		reg2
  | (Burm.reg_CVCI_INDIRC_disp disp, _) ->
		let disp' = walk disp in
	  let reg = new "reg" in
	  say (reg^" <- CVCI (INDIRC ("^disp'^"))\n"); 
		reg
  | (Burm.reg_I0I, _) ->
		let reg = new "reg" in
	  say (reg^" <- ZERO\n"); 
		reg
  | (Burm.reg_disp disp, _) ->
		let disp' = walk disp in
	  let reg = new "reg" in
	  say (reg^" <- "^disp'^"\n"); 
		reg
  | (Burm.disp_ADDI_reg_con (reg,con), _) ->
		let (reg',con') = (walk reg, walk con) in
	  let disp = new "disp" in
	  say (disp^" <- ADDI ("^reg'^","^con'^")\n"); 
		disp
  | (Burm.disp_ADDRLP, ADDRLP addr) ->
		let disp = new "disp" in
	  say (disp^" <- ADDRLP "^addr^"\n"); 
		disp
  | (Burm.rc_con con, _) ->
		let con' = walk con in
	  let rc = new "rc" in
	  say (rc^" <- "^con'^"\n"); 
		rc
  | walk (Burm.rc_reg reg, _) ->
		let reg' = walk reg in
	  let rc = new "rc" in
	  say (rc^" <- "^reg'^"\n"); 
		rc
  | (Burm.con_CNSTI, CNSTI i) ->
		let con = new "con" in
	  say (con^" <- CNSTI "^(Int.toString i)^"\n"); 
		con
  | (Burm.con_I0I, _) ->
		let con = new "con" in
	  say (con^" <- CNSTI ZERO\n"); 
		con
  | _ -> (print "Error, bad match in walk\n"; raise Match)


  let doit t = walk (Burm.reduce t)

  (*
   * int p;
   * char c;
   * p = c+4;
   *)
  let a = ASGNI (ADDRLP "p",
		 ADDI (CVCI (INDIRC (ADDRLP "c")),
		       CNSTI 4))

end

